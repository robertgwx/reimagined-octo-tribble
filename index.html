<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atlantic Forecast Regions Wind Warnings</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- LeafletJS for the interactive map -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <!-- Leaflet.pattern for hatching -->
    <script src="https://unpkg.com/leaflet.pattern/dist/leaflet.pattern.js"></script>
    <style>
        /* Set a specific height for the map container */
        #map { 
            height: 100vh; 
            width: 100vw;
        }
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevent scrollbars */
        }
        /* Custom Leaflet popup styles */
        .leaflet-popup-content-wrapper {
            background-color: #ffffff;
            color: #333;
            border-radius: 8px;
            box-shadow: 0 4px 14px rgba(0,0,0,0.15);
        }
        .leaflet-popup-content {
            margin: 14px 20px;
            font-size: 14px;
        }
        .leaflet-popup-content b {
            font-weight: 700;
            color: #1f2937;
        }
        .leaflet-popup-tip-container {
            width: 40px;
            height: 20px;
        }
        .leaflet-popup-tip {
             background: #ffffff;
             border: none;
             box-shadow: none;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100">
    <!-- Main Map Container -->
    <div id="map" class="relative z-0"></div>

    <!-- Control Panel Overlay -->
    <div class="absolute top-4 left-4 p-4 z-[1000]">
        <div class="bg-white/80 backdrop-blur-sm rounded-xl shadow-lg p-6 w-72">
            <h1 class="text-xl font-bold text-gray-800">Wind Warning Control</h1>
            <div class="mt-4 space-y-4">
                <div>
                    <label for="sustained-wind-input" class="block text-sm font-medium text-gray-700">Sustained Wind (km/h)</label>
                    <input type="number" id="sustained-wind-input" placeholder="e.g., 70" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2">
                </div>
                 <div>
                    <label for="gust-wind-input" class="block text-sm font-medium text-gray-700">Gust Wind (km/h)</label>
                    <input type="number" id="gust-wind-input" placeholder="e.g., 100" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2">
                </div>
            </div>
            <div class="mt-4 flex space-x-2">
                <button id="update-map-btn" class="flex-1 bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition-colors duration-300">
                    Update Map
                </button>
                 <button id="clear-map-btn" class="flex-1 bg-gray-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-600 transition-colors duration-300">
                    Clear
                </button>
            </div>
            <div class="mt-6">
                <h2 class="text-lg font-semibold text-gray-700">Legend</h2>
                <div class="mt-2 space-y-2">
                    <div class="flex items-center">
                        <div class="w-5 h-5 rounded-sm bg-yellow-400 border border-gray-400 mr-3"></div>
                        <span class="text-sm">Yellow Warning (Fill)</span>
                    </div>
                     <div class="flex items-center">
                        <div class="w-5 h-5 rounded-sm bg-orange-500 border border-gray-400 mr-3"></div>
                        <span class="text-sm">Orange Warning (Fill)</span>
                    </div>
                     <div class="flex items-center">
                        <div class="w-5 h-5 rounded-sm bg-red-600 border border-gray-400 mr-3"></div>
                        <span class="text-sm">Red Warning (Fill)</span>
                    </div>
                    <div class="flex items-center">
                        <div class="w-5 h-5 rounded-sm mr-3" style="background: repeating-linear-gradient(45deg, #9ca3af, #9ca3af 5px, rgba(255,255,255,0.2) 5px, rgba(255,255,255,0.2) 10px);"></div>
                        <span class="text-sm">Local Effects (Hatching)</span>
                    </div>
                </div>
            </div>
            <!-- Debug Info -->
            <div class="mt-4">
                <h3 class="text-sm font-medium text-gray-700">Debug Info</h3>
                <div id="debug-info" class="text-xs text-gray-600 mt-1">
                    <!-- Debug information will be displayed here -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- Status Overlay -->
    <div id="status-overlay" class="absolute inset-0 bg-white/50 backdrop-blur-sm flex justify-center items-center z-20">
        <div id="status-content" class="flex flex-col items-center text-center p-4">
            <!-- Status content will be inserted by JS -->
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', async function () {
            // --- UI Elements ---
            const statusOverlay = document.getElementById('status-overlay');
            const statusContent = document.getElementById('status-content');
            const sustainedWindInput = document.getElementById('sustained-wind-input');
            const gustWindInput = document.getElementById('gust-wind-input');
            const updateMapBtn = document.getElementById('update-map-btn');
            const clearMapBtn = document.getElementById('clear-map-btn');
            const debugInfo = document.getElementById('debug-info');
            
            const loadingSpinnerHTML = `
                <svg class="animate-spin h-10 w-10 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <p class="mt-4 text-gray-700 font-semibold">Loading and parsing GML data...</p>
            `;
            
            // --- Map Initialization ---
            const map = L.map('map').setView([55, -70], 4);
            const regionsLayerGroup = L.layerGroup().addTo(map);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
            }).addTo(map);

            // --- Warning Tier Definitions ---
            const WARNING_TIERS = {
                RED: { threshold: 120, color: '#dc2626', hatchColor: '#b91c1c' },
                ORANGE: { threshold: 90, color: '#f97316', hatchColor: '#ea580c' },
                YELLOW: { threshold: 70, color: '#facc15', hatchColor: '#eab308' },
                NONE: { color: 'transparent', hatchColor: '#3b82f6' }
            };

            // --- Define categories and their properties here ---
            const CATEGORY_DEFS = {
                Offshore: {
                    maxSustained: 90,
                    maxGust: 110,
                    localEffects: false
                },
                Coastal: {
                    maxSustained: 80,
                    maxGust: 100,
                    localEffects: true,
                    localHatchThresholds: { YELLOW: 70, ORANGE: 90, RED: 110 }
                },
                Inland: {
                    maxSustained: 60,
                    maxGust: 80,
                    localEffects: false
                }
            };
            
            const regionProperties = {
                "land_standard_coarse.4": { category: 'Coastal' }, // Kings County
                "land_standard_coarse.5": { category: 'Coastal' }, // Annapolis County
                "land_standard_coarse.6": { category: 'Coastal' }, // Digby County
                "land_standard_coarse.7": { category: 'Coastal' }, // Lunenburg County
                "land_standard_coarse.8": { category: 'Coastal' }, // Queens County
                "land_standard_coarse.9": { category: 'Coastal' }, // Shelburne County
                "land_standard_coarse.10": { category: 'Offshore' }, // Yarmouth County
                "land_standard_coarse.11": { category: 'Inland' }, // Cumberland County - Minas Shore
                "land_standard_coarse.12": { category: 'Inland' }, // Cumberland County North and Cobequid Pass
                "land_standard_coarse.13": { category: 'Inland' }, // Colchester County - Cobequid Bay
                "land_standard_coarse.14": { category: 'Inland' }, // Colchester County North
                "land_standard_coarse.15": { category: 'Inland' }, // Hants County
                "land_standard_coarse.16": { category: 'Inland' }, // Colchester County - Truro and south
                "land_standard_coarse.17": { category: 'Inland' }, // Halifax Metro and Halifax County West
                "land_standard_coarse.18": { category: 'Coastal' }, // Halifax County - east of Porters Lake
                "land_standard_coarse.19": { category: 'Offshore' }, // Pictou County
                "land_standard_coarse.20": { category: 'Coastal' }, // Guysborough County
                "land_standard_coarse.21": { category: 'Coastal' }, // Antigonish County
                "land_standard_coarse.22": { category: 'Inland' }, // Richmond County
                "land_standard_coarse.23": { category: 'Coastal' }, // Inverness County - south of Mabou
                "land_standard_coarse.24": { category: 'Coastal' }, // Inverness County - Mabou and north
                "land_standard_coarse.25": { category: 'Coastal' }, // Victoria County
                "land_standard_coarse.26": { category: 'Offshore' }, // Sydney Metro and Cape Breton County
                "land_standard_coarse.27": { category: 'Coastal' }, // Fredericton and Southern York County
                "land_standard_coarse.28": { category: 'Inland' }, // Oromocto and Sunbury County
                "land_standard_coarse.29": { category: 'Inland' }, // Grand Lake and Queens County
                "land_standard_coarse.30": { category: 'Inland' }, // Sussex/Kennebecasis Valley and Kings County
                "land_standard_coarse.31": { category: 'Coastal' }, // Saint John and County
                "land_standard_coarse.32": { category: 'Coastal' }, // St. Stephen and Northern Charlotte County
                "land_standard_coarse.33": { category: 'Inland' }, // Grand Manan and Coastal Charlotte County
                "land_standard_coarse.34": { category: 'Inland' }, // Woodstock and Carleton County
                "land_standard_coarse.35": { category: 'Inland' }, // Stanley - Doaktown - Blackville Area
                "land_standard_coarse.36": { category: 'Inland' }, // Kent County
                "land_standard_coarse.37": { category: 'Coastal' }, // Moncton and Southeast New Brunswick
                "land_standard_coarse.38": { category: 'Inland' }, // Kouchibouguac National Park
                "land_standard_coarse.39": { category: 'Inland' }, // Fundy National Park
                "land_standard_coarse.40": { category: 'Inland' }, // Edmundston and Madawaska County
                "land_standard_coarse.41": { category: 'Inland' }, // Restigouche County
                "land_standard_coarse.42": { category: 'Inland' }, // Grand Falls and Victoria County
                "land_standard_coarse.43": { category: 'Inland' }, // Mount Carleton - Renous Highway
                "land_standard_coarse.44": { category: 'Inland' }, // Bathurst and Chaleur Region
                "land_standard_coarse.45": { category: 'Inland' }, // Miramichi and area
                "land_standard_coarse.46": { category: 'Inland' }, // Acadian Peninsula
                "land_standard_coarse.47": { category: 'Inland' }, // Kings County P.E.I.
                "land_standard_coarse.48": { category: 'Inland' }, // Queens County P.E.I.
                "land_standard_coarse.49": { category: 'Inland' }, // Prince County P.E.I.
                "land_standard_coarse.50": { category: 'Inland' }, // Avalon Peninsula North (FIXED: removed extra spaces)
                "land_standard_coarse.51": { category: 'Inland' }, // Avalon Peninsula Southeast
                "land_standard_coarse.52": { category: 'Inland' }, // St. John's and vicinity
                "land_standard_coarse.53": { category: 'Inland' }, // Avalon Peninsula Southwest
                "land_standard_coarse.54": { category: 'Coastal' }, // Burin Peninsula
                "land_standard_coarse.55": { category: 'Coastal' }, // Connaigre
                "land_standard_coarse.56": { category: 'Coastal' }, // Burgeo - Ramea
                "land_standard_coarse.57": { category: 'Coastal' }, // Channel-Port aux Basques and vicinity
                "land_standard_coarse.58": { category: 'Inland' }, // Corner Brook and vicinity
                "land_standard_coarse.59": { category: 'Inland' }, // Deer Lake - Humber Valley
                "land_standard_coarse.60": { category: 'Offshore' }, // Gros Morne
                "land_standard_coarse.61": { category: 'Inland' }, // Bay St. Geroge
                "land_standard_coarse.62": { category: 'Inland' }, // Buchans and the interior
                "land_standard_coarse.63": { category: 'Inland' }, // Grand Falls-Windsor and vicinity
                "land_standard_coarse.64": { category: 'Inland' }, // Bay of Exploits
                "land_standard_coarse.65": { category: 'Coastal' },  // Bonavista North
                "land_standard_coarse.66": { category: 'Coastal' },  // Bonavista Peninsula
                "land_standard_coarse.67": { category: 'Coastal' },  // Clarenville and vicinity
                "land_standard_coarse.68": { category: 'Coastal' },  // Gander and vicinity
                "land_standard_coarse.69": { category: 'Coastal' },  // Green Bay - White Bay
                "land_standard_coarse.70": { category: 'Coastal' },  // Terra Nova
                "land_standard_coarse.71": { category: 'Coastal' },  // Northern Peninsula East
                "land_standard_coarse.72": { category: 'Coastal' },  // Parson's Pond - Hawke's Bay
                "land_standard_coarse.73": { category: 'Coastal' },  // Port Saunders and the Straits
                "land_standard_coarse.74": { category: 'Coastal' },  // Red Bay to L'Anse-au-Clair
                "land_standard_coarse.75": { category: 'Coastal' },  // Norman Bay to Lodge Bay
                "land_standard_coarse.76": { category: 'Coastal' },  // Cartwright to Black Tickle
                "land_standard_coarse.77": { category: 'Coastal' },  // Rigolet and vicinity
                "land_standard_coarse.78": { category: 'Coastal' },  // Postville - Makkovik
                "land_standard_coarse.79": { category: 'Coastal' },  // Hopedale and vicinity
                "land_standard_coarse.80": { category: 'Coastal' },  // Nain and vicinity
                "land_standard_coarse.81": { category: 'Inland' },  // Upper Lake Melville
                "land_standard_coarse.82": { category: 'Inland' },  // Eagle River
                "land_standard_coarse.83": { category: 'Inland' },  // Churchill Valley
                "land_standard_coarse.84": { category: 'Inland' },  // Churchill Falls and vicinity
                "land_standard_coarse.85": { category: 'Inland' },  // Labrador City and Wabush
            };
                            
            let polygonLayers = {};

            // --- Create Hatching Patterns ---
            const patterns = {};
            ['YELLOW', 'ORANGE', 'RED'].forEach(tier => {
                patterns[tier] = new L.Pattern({ angle: 45, weight: 2, color: WARNING_TIERS[tier].hatchColor, spaceWeight: 6, spaceColor: 'transparent' });
                patterns[tier].addTo(map);
            });
            
            const gmlFileUrl = 'land_standard_exaggerated_atlantic.gml';

            async function loadAndDisplayGML() {
                statusContent.innerHTML = loadingSpinnerHTML;
                statusOverlay.style.display = 'flex';
                try {
                    const response = await fetch(gmlFileUrl);
                    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                    const gmlString = await response.text();
                    processGML(gmlString);
                    resetMapStyles(); // Set initial transparent state
                } catch (error) {
                    console.error('Error fetching or processing GML file:', error);
                    statusContent.innerHTML = `<p class="text-red-500 font-semibold">Failed to load map data. ${error.message}</p>`;
                    setTimeout(() => statusOverlay.style.display = 'none', 3000);
                }
            }

            function processGML(gmlString) {
                const parser = new DOMParser();
                const gmlDoc = parser.parseFromString(gmlString, "application/xml");
                if (gmlDoc.querySelector("parsererror")) throw new Error('Could not parse GML file.');
                
                const featureMembers = gmlDoc.querySelectorAll("gml\\:featureMember, featureMember");
                if (featureMembers.length === 0) throw new Error('No features found in GML file.');
                
                const allLatLngs = [];
                let processedCount = 0;

                featureMembers.forEach(member => {
                    const fid = member.firstElementChild.getAttribute('fid');
                    const name = member.querySelector("ogr\\:NAME, NAME")?.textContent || fid;
                    
                    // Consistent category matching
                    let regionCat = 'Inland'; // Default
                    if (regionProperties[fid]) {
                        regionCat = String(regionProperties[fid].category).trim();
                    }

                    const props = {
                        name: name,
                        category: regionCat,
                        ...CATEGORY_DEFS[regionCat]
                    };
                    
                    // More robust coordinate extraction
                    const extractPolygonCoordinates = (element) => {
                        const coordTags = element.querySelectorAll("gml\\:coordinates, coordinates");
                        const polygons = [];

                        coordTags.forEach(coordTag => {
                            const coordsStr = coordTag.textContent.trim();
                            if (!coordsStr) return;

                            // Consistent coordinate parsing
                            const coords = coordsStr.split(/\s+/)
                                .filter(coord => coord.includes(','))
                                .map(coord => {
                                    const [lon, lat] = coord.split(',').map(num => parseFloat(num.trim()));
                                    return !isNaN(lat) && !isNaN(lon) ? [lat, lon] : null;
                                })
                                .filter(coord => coord !== null);

                            // Strict polygon validation
                            if (coords.length > 3) {
                                // Ensure polygon is closed with minimal deviation
                                const first = coords[0];
                                const last = coords[coords.length - 1];
                                
                                // Use a small threshold for closing the polygon
                                const CLOSE_THRESHOLD = 0.0001; // Adjust if needed
                                const isClosed = 
                                    Math.abs(first[0] - last[0]) < CLOSE_THRESHOLD && 
                                    Math.abs(first[1] - last[1]) < CLOSE_THRESHOLD;

                                if (!isClosed) {
                                    coords.push(first);
                                }

                                polygons.push(coords);
                            }
                        });

                        return polygons;
                    };

                    // Extract polygons with consistent method
                    const regionPolygons = extractPolygonCoordinates(member);

                    // Collect unique lat/lngs
                    regionPolygons.forEach(polygon => {
                        polygon.forEach(latlng => {
                            allLatLngs.push(latlng);
                        });
                    });

                    if (regionPolygons.length > 0) {
                        // Create feature group with consistent styling from the start
                        const multiPolygonLayer = L.featureGroup(
                            regionPolygons.map(polygonCoords => 
                                L.polygon(polygonCoords, {
                                    color: 'black',
                                    weight: 1,
                                    fillOpacity: 0,
                                    fillColor: 'transparent'
                                })
                            )
                        );
                        
                        let popupContent = `<b>${props.name}</b><br>Category: ${regionCat}<br>FID: ${fid}`;
                        popupContent += `<br>Polygons: ${regionPolygons.length}`;
                        popupContent += `<br>Max Sustained: ${props.maxSustained} km/h<br>Max Gust: ${props.maxGust} km/h`;
                        
                        multiPolygonLayer.bindPopup(popupContent);
                        regionsLayerGroup.addLayer(multiPolygonLayer);
                        
                        // Store both the layer and its properties
                        polygonLayers[fid] = {
                            layer: multiPolygonLayer,
                            properties: props
                        };
                        processedCount++;
                        
                        console.log(`Matched: ${name} (${fid}) -> ${regionCat}, Polygons: ${regionPolygons.length}`);
                    }
                });
                
                if (allLatLngs.length > 0) map.fitBounds(L.latLngBounds(allLatLngs), { padding: [50, 50] });
                statusOverlay.style.display = 'none';
                
                debugInfo.innerHTML = `Loaded ${processedCount} regions from GML`;
                console.log(`Processed ${processedCount} regions from GML`);
            }

            
            // FIXED: Completely rewritten warning tier logic
            function getTierByCategory(speed, categoryMax) {
                if (!speed || speed <= 0) return 'NONE';
                
                // Calculate thresholds based on percentage of category maximum
                // Yellow: 70% of max, Orange: 90% of max, Red: 110% of max (can exceed)
                const yellowThreshold = Math.round(0.7 * categoryMax);
                const orangeThreshold = Math.round(0.9 * categoryMax);
                const redThreshold = Math.round(1.1 * categoryMax);
                
                if (speed >= redThreshold) return 'RED';
                if (speed >= orangeThreshold) return 'ORANGE';
                if (speed >= yellowThreshold) return 'YELLOW';
                return 'NONE';
            }

            
            function updateMapStyles() {
                const sustainedSpeed = parseFloat(sustainedWindInput.value) || 0;
                const gustSpeed = parseFloat(gustWindInput.value) || 0;
                
                console.log(`=== UPDATE MAP STYLES ===`);
                console.log(`Input winds: sustained=${sustainedSpeed}, gust=${gustSpeed}`);
                
                let debugText = `Winds: ${sustainedSpeed}km/h sustained, ${gustSpeed}km/h gust<br>`;
                let processedCount = 0;
                let filledCount = 0;

                // Precompute warning tiers for all regions to ensure consistent styling
                const regionWarnings = {};

                // First pass: determine tiers for all regions
                for (const fid in polygonLayers) {
                    const layerData = polygonLayers[fid];
                    const props = layerData.properties;

                    const sustainedTier = getTierByCategory(sustainedSpeed, props.maxSustained);
                    const gustTier = getTierByCategory(gustSpeed, props.maxGust);

                    const tierOrder = ['NONE', 'YELLOW', 'ORANGE', 'RED'];
                    const sustainedIdx = tierOrder.indexOf(sustainedTier);
                    const gustIdx = tierOrder.indexOf(gustTier);
                    const finalTier = tierOrder[Math.max(sustainedIdx, gustIdx)];

                    regionWarnings[fid] = finalTier;
                }

                // Second pass: apply styles
                for (const fid in polygonLayers) {
                    const layerData = polygonLayers[fid];
                    const layer = layerData.layer;
                    const props = layerData.properties;
                    
                    processedCount++;

                    const finalTier = regionWarnings[fid];

                    console.log(`${props.name} (${fid}): Final Tier: ${finalTier}`);

                    if (finalTier !== 'NONE') filledCount++;

                    const styleOptions = {
                        color: 'black',
                        weight: 1,
                        fillColor: WARNING_TIERS[finalTier].color,
                        fillOpacity: finalTier === 'NONE' ? 0 : 0.6
                    };

                    // Ensure ALL layers within the feature group get the EXACT same style
                    layer.eachLayer(subLayer => {
                        // Clone the style options to ensure no reference issues
                        const exactStyleOptions = { ...styleOptions };
                        subLayer.setStyle(exactStyleOptions);
                    });
                }
                
                debugText += `Processed ${processedCount} regions, filled ${filledCount} with warnings`;
                debugInfo.innerHTML = debugText;
                console.log(`Processed ${processedCount} regions, filled ${filledCount} with warnings`);
            }

            function resetMapStyles() {
                sustainedWindInput.value = '';
                gustWindInput.value = '';
                let resetCount = 0;
                
                for (const fid in polygonLayers) {
                    const layerData = polygonLayers[fid];
                    let layer;
                    
                    // Handle both old format (just layer) and new format (object with layer and properties)
                    if (layerData.layer) {
                        layer = layerData.layer;
                    } else {
                        layer = layerData;
                    }
                    
                    if (layer) {
                        layer.setStyle({
                            color: 'black',
                            weight: 1,
                            fillOpacity: 0,
                            fillPattern: null,
                            fillColor: 'transparent'
                        });
                        resetCount++;
                    }
                }
                
                debugInfo.innerHTML = `Reset ${resetCount} regions to transparent`;
                console.log(`Reset ${resetCount} regions`);
            }
            
            updateMapBtn.addEventListener('click', updateMapStyles);
            clearMapBtn.addEventListener('click', resetMapStyles);

            loadAndDisplayGML();
        });
    </script>
</body>
</html>