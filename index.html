<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atlantic Forecast Regions Wind Warnings</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- LeafletJS for the interactive map -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <!-- Leaflet.pattern for hatching -->
    <script src="https://unpkg.com/leaflet.pattern/dist/leaflet.pattern.js"></script>
    <style>
        /* Set a specific height for the map container */
        #map { 
            height: 100vh; 
            width: 100vw;
        }
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevent scrollbars */
        }
        /* Custom Leaflet popup styles */
        .leaflet-popup-content-wrapper {
            background-color: #ffffff;
            color: #333;
            border-radius: 8px;
            box-shadow: 0 4px 14px rgba(0,0,0,0.15);
        }
        .leaflet-popup-content {
            margin: 14px 20px;
            font-size: 14px;
        }
        .leaflet-popup-content b {
            font-weight: 700;
            color: #1f2937;
        }
        .leaflet-popup-tip-container {
            width: 40px;
            height: 20px;
        }
        .leaflet-popup-tip {
             background: #ffffff;
             border: none;
             box-shadow: none;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100">
    <!-- Main Map Container -->
    <div id="map" class="relative z-0"></div>

    <!-- Control Panel Overlay -->
    <div class="absolute top-4 left-4 p-4 z-[1000]">
        <div class="bg-white/80 backdrop-blur-sm rounded-xl shadow-lg p-6 w-72">
            <h1 class="text-xl font-bold text-gray-800">Wind Warning Control</h1>
            <div class="mt-4 space-y-4">
                <div>
                    <label for="sustained-wind-input" class="block text-sm font-medium text-gray-700">Sustained Wind (km/h)</label>
                    <input type="number" id="sustained-wind-input" placeholder="e.g., 70" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2">
                </div>
                 <div>
                    <label for="gust-wind-input" class="block text-sm font-medium text-gray-700">Gust Wind (km/h)</label>
                    <input type="number" id="gust-wind-input" placeholder="e.g., 100" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm p-2">
                </div>
            </div>
            <div class="mt-4 flex space-x-2">
                <button id="update-map-btn" class="flex-1 bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition-colors duration-300">
                    Update Map
                </button>
                 <button id="clear-map-btn" class="flex-1 bg-gray-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-600 transition-colors duration-300">
                    Clear
                </button>
            </div>
            <div class="mt-6">
                <h2 class="text-lg font-semibold text-gray-700">Legend</h2>
                <div class="mt-2 space-y-2">
                    <div class="flex items-center">
                        <div class="w-5 h-5 rounded-sm bg-yellow-400 border border-gray-400 mr-3"></div>
                        <span class="text-sm">Yellow Warning (Fill)</span>
                    </div>
                     <div class="flex items-center">
                        <div class="w-5 h-5 rounded-sm bg-orange-500 border border-gray-400 mr-3"></div>
                        <span class="text-sm">Orange Warning (Fill)</span>
                    </div>
                     <div class="flex items-center">
                        <div class="w-5 h-5 rounded-sm bg-red-600 border border-gray-400 mr-3"></div>
                        <span class="text-sm">Red Warning (Fill)</span>
                    </div>
                    <div class="flex items-center">
                        <div class="w-5 h-5 rounded-sm mr-3" style="background: repeating-linear-gradient(45deg, #9ca3af, #9ca3af 5px, rgba(255,255,255,0.2) 5px, rgba(255,255,255,0.2) 10px);"></div>
                        <span class="text-sm">Local Effects (Hatching)</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Status Overlay -->
    <div id="status-overlay" class="absolute inset-0 bg-white/50 backdrop-blur-sm flex justify-center items-center z-20">
        <div id="status-content" class="flex flex-col items-center text-center p-4">
            <!-- Status content will be inserted by JS -->
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // --- UI Elements ---
            const statusOverlay = document.getElementById('status-overlay');
            const statusContent = document.getElementById('status-content');
            const sustainedWindInput = document.getElementById('sustained-wind-input');
            const gustWindInput = document.getElementById('gust-wind-input');
            const updateMapBtn = document.getElementById('update-map-btn');
            const clearMapBtn = document.getElementById('clear-map-btn');
            
            const loadingSpinnerHTML = `
                <svg class="animate-spin h-10 w-10 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <p class="mt-4 text-gray-700 font-semibold">Loading and parsing GML data...</p>
            `;
            
            // --- Map Initialization ---
            const map = L.map('map').setView([55, -70], 4);
            const regionsLayerGroup = L.layerGroup().addTo(map);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
            }).addTo(map);

            // --- Warning Tier Definitions ---
            const WARNING_TIERS = {
                RED: { threshold: 120, color: '#dc2626', hatchColor: '#b91c1c' },
                ORANGE: { threshold: 90, color: '#f97316', hatchColor: '#ea580c' },
                YELLOW: { threshold: 70, color: '#facc15', hatchColor: '#eab308' },
                NONE: { color: 'transparent', hatchColor: '#3b82f6' }
            };

            // --- Data Simulation ---
            const regionProperties = {
                "land_standard_coarse.4": { maxSustained: 100, maxGust: 130, localEffects: true, localHatchThresholds: { YELLOW: 80, ORANGE: 110, RED: 140 } },
                "land_standard_coarse.5": { maxSustained: 95, maxGust: 110, localEffects: false },
                "land_standard_coarse.6": { maxSustained: 110, maxGust: 125, localEffects: true, localHatchThresholds: { YELLOW: 90, ORANGE: 115, RED: 135 } },
                "land_standard_coarse.9": { maxSustained: 120, maxGust: 140, localEffects: true, localHatchThresholds: { YELLOW: 100, ORANGE: 130, RED: 150 } },
                "land_standard_coarse.10": { maxSustained: 125, maxGust: 145, localEffects: true, localHatchThresholds: { YELLOW: 110, ORANGE: 135, RED: 155 } },
                "land_standard_coarse.26": { maxSustained: 90, maxGust: 115, localEffects: true, localHatchThresholds: { YELLOW: 75, ORANGE: 100, RED: 125 } },
                "land_standard_coarse.54": { maxSustained: 130, maxGust: 150, localEffects: true, localHatchThresholds: { YELLOW: 100, ORANGE: 120, RED: 140 } },
                "land_standard_coarse.60": { maxSustained: 80, maxGust: 95, localEffects: false },
                "land_standard_coarse.132": { maxSustained: 115, maxGust: 135, localEffects: true, localHatchThresholds: { YELLOW: 95, ORANGE: 125, RED: 145 } },
                "land_standard_coarse.118": { maxSustained: 85, maxGust: 105, localEffects: true, localHatchThresholds: { YELLOW: 70, ORANGE: 95, RED: 115 } },
            };
            
            let polygonLayers = {};

            // --- Create Hatching Patterns ---
            const patterns = {};
            ['YELLOW', 'ORANGE', 'RED'].forEach(tier => {
                patterns[tier] = new L.Pattern({ angle: 45, weight: 2, color: WARNING_TIERS[tier].hatchColor, spaceWeight: 6, spaceColor: 'transparent' });
                patterns[tier].addTo(map);
            });
            
            const gmlFileUrl = 'land_standard_exaggerated_atlantic.gml';

            async function loadAndDisplayGML() {
                statusContent.innerHTML = loadingSpinnerHTML;
                statusOverlay.style.display = 'flex';
                try {
                    const response = await fetch(gmlFileUrl);
                    if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);
                    const gmlString = await response.text();
                    processGML(gmlString);
                    resetMapStyles(); // Set initial transparent state
                } catch (error) {
                    console.error('Error fetching or processing GML file:', error);
                    statusContent.innerHTML = `<p class="text-red-500 font-semibold">Failed to load map data.</p>`;
                }
            }

            function processGML(gmlString) {
                const parser = new DOMParser();
                const gmlDoc = parser.parseFromString(gmlString, "application/xml");
                if (gmlDoc.querySelector("parsererror")) throw new Error('Could not parse GML file.');
                
                const featureMembers = gmlDoc.querySelectorAll("gml\\:featureMember, featureMember");
                if (featureMembers.length === 0) throw new Error('No features found in GML file.');
                
                const allLatLngs = [];
                featureMembers.forEach(member => {
                    const fid = member.firstElementChild.getAttribute('fid');
                    const name = member.querySelector("ogr\\:NAME, NAME")?.textContent || 'Unnamed Region';
                    const geometries = member.querySelectorAll("gml\\:Polygon, Polygon, gml\\:MultiPolygon, MultiPolygon");

                    geometries.forEach(geom => {
                        geom.querySelectorAll("gml\\:coordinates, coordinates").forEach(coordTag => {
                            const coordsStr = coordTag.textContent.trim();
                            if (coordsStr) {
                                const latLngs = coordsStr.split(/\s+/).filter(p => p).map(pair => {
                                    const [lon, lat] = pair.split(',').map(parseFloat);
                                    if (!isNaN(lat) && !isNaN(lon)) {
                                        allLatLngs.push([lat, lon]);
                                        return [lat, lon];
                                    }
                                    return null;
                                }).filter(p => p);

                                if (latLngs.length > 2) {
                                    const polygonLayer = L.polygon(latLngs);
                                    let popupContent = `<b>${name}</b>`;
                                    if (regionProperties[fid]) {
                                        popupContent += `<br>Max Sustained: ${regionProperties[fid].maxSustained} km/h<br>Max Gust: ${regionProperties[fid].maxGust} km/h<br>${regionProperties[fid].localEffects ? 'Prone to local effects' : ''}`;
                                    }
                                    polygonLayer.bindPopup(popupContent);
                                    regionsLayerGroup.addLayer(polygonLayer);
                                    polygonLayers[fid] = polygonLayer;
                                }
                            }
                        });
                    });
                });
                
                if (allLatLngs.length > 0) map.fitBounds(L.latLngBounds(allLatLngs), { padding: [50, 50] });
                statusOverlay.style.display = 'none';
            }
            
            function getWarningTier(windSpeed, maxWind, type = 'sustained') {
                const tiers = ['RED', 'ORANGE', 'YELLOW'];
                if (windSpeed > maxWind) return 'NONE';
                for (const tier of tiers) {
                    if (windSpeed >= WARNING_TIERS[tier].threshold) return tier;
                }
                return 'NONE';
            }

             function getLocalEffectTier(gustSpeed, thresholds) {
                if (!thresholds) return 'NONE';
                if (gustSpeed >= thresholds.RED) return 'RED';
                if (gustSpeed >= thresholds.ORANGE) return 'ORANGE';
                if (gustSpeed >= thresholds.YELLOW) return 'YELLOW';
                return 'NONE';
            }

            function updateMapStyles() {
                const sustainedSpeed = parseFloat(sustainedWindInput.value) || 0;
                const gustSpeed = parseFloat(gustWindInput.value) || 0;

                for (const fid in polygonLayers) {
                    const layer = polygonLayers[fid];
                    const props = regionProperties[fid] || { maxSustained: 70, maxGust: 90, localEffects: false };
                    
                    const sustainedTier = getWarningTier(sustainedSpeed, props.maxSustained);
                    const hatchTier = props.localEffects ? getLocalEffectTier(gustSpeed, props.localHatchThresholds) : 'NONE';
                    
                    const fillTier = sustainedTier;
                    
                    const styleOptions = {
                        color: WARNING_TIERS[sustainedTier !== 'NONE' ? sustainedTier : hatchTier].hatchColor || '#3b82f6',
                        weight: 2,
                        fillColor: WARNING_TIERS[fillTier].color,
                        fillOpacity: (fillTier === 'NONE' && hatchTier === 'NONE') ? 0 : 0.6,
                        fillPattern: hatchTier !== 'NONE' ? patterns[hatchTier] : null
                    };

                    layer.setStyle(styleOptions);
                }
            }

            function resetMapStyles() {
                sustainedWindInput.value = '';
                gustWindInput.value = '';
                for (const fid in polygonLayers) {
                    polygonLayers[fid].setStyle({
                        color: '#3b82f6',
                        weight: 1,
                        fillOpacity: 0,
                        fillPattern: null
                    });
                }
            }
            
            updateMapBtn.addEventListener('click', updateMapStyles);
            clearMapBtn.addEventListener('click', resetMapStyles);

            loadAndDisplayGML();
        });
    </script>
</body>
</html>

